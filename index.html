<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Gravity Swap Chaos</title>
<style>
body{
  margin:0;
  overflow:hidden;
  font-family:sans-serif;
  background:#111;
}
#gameArea{
  position:relative;
  width:100vw;
  height:100vh;
  background:#111;
  overflow:hidden;
}
.player{
  width:40px;
  height:40px;
  background:lime;
  position:absolute;
  top:50%;
  left:50%;
  margin-left:-20px;
  margin-top:-20px;
  transition:0.1s;
}
.obstacle{
  width:50px;
  height:50px;
  background:red;
  position:absolute;
}
#scoreDisplay{
  position:absolute;
  top:10px;
  left:10px;
  color:#fff;
  font-size:20px;
  font-weight:bold;
  z-index:1000;
}
</style>
</head>
<body>

<div id="gameArea">
<div id="scoreDisplay">Score: 0</div>
<div class="player" id="player"></div>
</div>

<script>
const gameArea=document.getElementById('gameArea');
const player=document.getElementById('player');
let score=0;
let gravity={x:0, y:1}; // initial gravity
let vx=0, vy=0;
let obstacles=[];
let lastGravityFlip=0;
let gameOver=false;

// Randomly flip gravity every 1.5 seconds
function randomGravity(){
  const dir=Math.floor(Math.random()*4);
  switch(dir){
    case 0: gravity={x:0,y:1}; break; // down
    case 1: gravity={x:0,y:-1}; break; // up
    case 2: gravity={x:1,y:0}; break; // right
    case 3: gravity={x:-1,y:0}; break; // left
  }
}

// Spawn random obstacles
function spawnObstacle(){
  const obs=document.createElement('div');
  obs.className='obstacle';
  obs.style.top=Math.random()*(window.innerHeight-50)+'px';
  obs.style.left=Math.random()*(window.innerWidth-50)+'px';
  gameArea.appendChild(obs);
  obstacles.push(obs);
}

// Update game state
function update(){
  if(gameOver) return;
  // gravity flip
  if(Date.now()-lastGravityFlip>1500){ randomGravity(); lastGravityFlip=Date.now();}
  // apply velocity
  vx+=gravity.x*0.5;
  vy+=gravity.y*0.5;
  let rect=player.getBoundingClientRect();
  let x=rect.left+vx;
  let y=rect.top+vy;
  // boundary check
  if(x<0||x>window.innerWidth-40||y<0||y>window.innerHeight-40){
    gameOver=true; endGame(); return;
  }
  player.style.left=x+'px';
  player.style.top=y+'px';
  // check collisions
  obstacles.forEach(o=>{
    let oRect=o.getBoundingClientRect();
    if(!(rect.right<oRect.left||rect.left>oRect.right||rect.bottom<oRect.top||rect.top>oRect.bottom)){
      gameOver=true; endGame();
    }
  });
  score++;
  document.getElementById('scoreDisplay').innerText='Score: '+score;
  requestAnimationFrame(update);
}

// Control with tap/click
document.addEventListener('click',()=>{
  vx+= (Math.random()-0.5)*10;
  vy+= (Math.random()-0.5)*10;
});

// spawn obstacles continuously
setInterval(spawnObstacle,1000);

// start game
update();

function endGame(){
  alert('ðŸ’¥ Game Over! Score: '+score);
  location.reload();
}
</script>

</body>
</html>
